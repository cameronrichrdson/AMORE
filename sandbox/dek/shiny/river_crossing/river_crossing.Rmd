---
title: River-crossing simulation
author: Dan Kelley (member of AMORE group)
date: 2023-05-28
runtime: shiny
---

A captain wants to cross a river to reach a certain point on the other shore.
Unfortunately, the rudder is faulty, and cannot be adjusted during the journey.
A similar problem means that the boat's forward speed cannot be adjusted
*en route.*

Use the tool to address questions like the following.

* What heading and speed should be chosen, for the default values for other settings?
* Can heading and speed be chosen independently of each other?
* Is cross-shore variation of current an important factor?
* Is it always possible to reach the destination?


```{r echo=FALSE}
library(shiny)
library(deSolve) # for lsoda()

heading2theta <- function(heading)
    (90 - heading) * pi / 180

# User Interface
ui <- fluidPage(titlePanel(title="", windowTitle="River Transit"),
    tags$script('$(document).on("keypress", function (e) { Shiny.onInputChange("keypress", e.which); Shiny.onInputChange("keypressTrigger", Math.random()); });'),
    style="text-indent:1em; background:#e6f3ff",
    fluidRow(
        column(2, sliderInput("ur", value=0.0, min=0.0, max=2.0, step=0.01,
                label="Current [m/s]")),
        column(3, selectInput("type", choices=c("constant", "parabolic"),
            label="Current Type")),
        column(2, sliderInput("width", value=200, min=200, max=1000, step=10,
                label="Width [m]")),
        column(2, sliderInput("ub", value=2, min=0.1, max=5.0, step=0.01,
                label="Speed [m/s]")),
        column(2, sliderInput("heading", value=0.0, min=-89.0, max=89.0, step=0.25,
                label="Heading [deg]"))),
    fluidRow(plotOutput("plot", height="300")))

# Server Functions
server <- function(input, output, session)
{
    output$plot <- renderPlot({
        # convert from nautical "heading" (CW from North) to mathematical "theta" (CCW from east)
        # River speed (parabolic in y)
        ur <- function(y, width, max) {
            if (input$type == "parabolic") {
                yy <- y / width
                ifelse(yy < 1, 4 * max * yy * (1 - yy), 0)
            } else {
                max
            }
        }
        # Dynamical function
        func <- function(t, y, parms)
        {
            X <- y[1] # extract eastward coordinate (with origin at southern red dot)
            Y <- y[2] # extract northward coordinate (with origin at southern red dot)
            u <- ur(Y, parms$width, parms$ur) + parms$ub * cos(parms$theta)
            v <- parms$ub * sin(parms$theta)
            list(c(u=u, v=v)) # return derivatives dX/dt and dY/dt
        }
        # set up parameters
        parms <- list(
            width=input$width,
            ur=input$ur,
            ub=input$ub,
            theta=heading2theta(input$heading))
        # Set up initial conditions (i.e. initial location)
        IC <- c(0, 0)
        # Establish reporting times.
        tmax <- 80 * input$width/input$ub # guess on time required
        times <- seq(0, tmax, length.out=2000)
        # Solve the DE
        sol <- lsoda(IC, times, func, parms=parms)
        # We don't actually model the north coast, so chop off data when we get a
        # little past that y value.  It would be easy to interpolate to find the
        # x and t values at this y, if desired.
        inwater <- sol[,3] < 1.02 * input$width
        sol <- sol[inwater,]
        # Plot
        par(mar=c(3, 3, 1, 1), mgp=c(2, 0.7, 0))
        plot(sol[, 2], sol[, 3], asp=1, type="l", lwd=2, ylim=c(-0.04*input$width, 1.04*input$width),
            yaxs="i", xlab="x [m]", ylab="y [m]", pch=20)
        grid()
        usr <- par("usr")
        polygon(c(usr[1], usr[1], usr[2], usr[2]), c(parms$width, usr[4], usr[4], parms$width), col="tan")
        polygon(c(usr[1], usr[1], usr[2], usr[2]), c(usr[3], 0, 0, usr[3]), col="tan")
        points(0, 0, col=2, pch=20, cex=2.5)
        points(0, input$width, col=2, pch=20, cex=2.5)
        # redraw
        lines(sol[, 2], sol[, 3], lwd=2)
        end <- which(is.finite(sol[,3]) & sol[,3] >= input$width)[1]
        mtext(sprintf("%.1f minutes", sol[end,1]/60))
    }, height="auto", pointsize=15)

    # Accept keypress '?'
    observeEvent(input$keypressTrigger,
        {
            if (intToUtf8(input$keypress) == "?") {
                showNotification(HTML("<b>Many rivers to cross</b><br><b>But I can't seem to find my way over</b><br>-- <i>Jimmy Cliff 1969</i>"),
                type="message", duration=NULL)
            }
        })
}

shinyApp(ui=ui, server=server)
```
